Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> bloc
Rule 2     bloc -> statement bloc
Rule 3     bloc -> statement
Rule 4     statement -> instruction SEMICOLON
Rule 5     statement -> instruction
Rule 6     instruction -> expression
Rule 7     instruction -> assignment
Rule 8     instruction -> iterative_exp
Rule 9     instruction -> echo_exp
Rule 10    echo_exp -> ECHO bloc
Rule 11    expression -> boolean_exp
Rule 12    expression -> arithmetic_exp
Rule 13    expression -> conditional_exp
Rule 14    boolean_exp -> boolean_exp AND boolean_exp
Rule 15    boolean_exp -> boolean_exp OR boolean_exp
Rule 16    boolean_exp -> TRUE
Rule 17    boolean_exp -> FALSE
Rule 18    boolean_exp -> variable
Rule 19    boolean_exp -> STRING
Rule 20    boolean_exp -> comparison_exp
Rule 21    boolean_exp -> LPAREN boolean_exp RPAREN
Rule 22    comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp
Rule 23    comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
Rule 24    comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp
Rule 25    comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
Rule 26    comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp
Rule 27    comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp
Rule 28    comparison_exp -> LPAREN comparison_exp RPAREN
Rule 29    arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp
Rule 30    arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp
Rule 31    arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp
Rule 32    arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp
Rule 33    arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp
Rule 34    arithmetic_exp -> LPAREN arithmetic_exp RPAREN
Rule 35    arithmetic_exp -> MINUS arithmetic_exp
Rule 36    arithmetic_exp -> num
Rule 37    arithmetic_exp -> variable
Rule 38    arithmetic_exp -> STRING
Rule 39    num -> NUMBER
Rule 40    num -> float
Rule 41    float -> NUMBER DOT NUMBER
Rule 42    variable -> NAME
Rule 43    assignment -> NAME EQUALS expression
Rule 44    conditional_exp -> IF boolean_exp AT bloc END
Rule 45    conditional_exp -> IF boolean_exp AT bloc ELSE bloc END
Rule 46    iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END
Rule 47    iterative_exp -> FOR assignment boolean_exp bloc AT bloc END
Rule 48    iterative_exp -> WHILE boolean_exp AT bloc END
Rule 49    iterative_exp -> WHILE boolean_exp bloc END

Terminals, with rules where they appear

AND                  : 14
AT                   : 44 45 46 46 46 47 48
DIVIDE               : 32
DOT                  : 41
ECHO                 : 10
ELSE                 : 45
END                  : 44 45 46 47 48 49
EQUALS               : 43
FALSE                : 17
FOR                  : 46 47
IF                   : 44 45
IS_BIGGER            : 22
IS_BIGGER_EQUALS     : 23
IS_DIFFERENT         : 27
IS_EQUALS            : 26
IS_SMALLER           : 24
IS_SMALLER_EQUALS    : 25
LPAREN               : 21 28 34
MINUS                : 30 35
MODULO               : 33
NAME                 : 42 43
NUMBER               : 39 41 41
OR                   : 15
PLUS                 : 29
RPAREN               : 21 28 34
SEMICOLON            : 4
STRING               : 19 38
TIMES                : 31
TRUE                 : 16
WHILE                : 48 49
error                : 

Nonterminals, with rules where they appear

arithmetic_exp       : 12 22 22 23 23 24 24 25 25 26 26 27 27 29 29 30 30 31 31 32 32 33 33 34 35
assignment           : 7 46 47
bloc                 : 1 2 10 44 45 45 46 46 47 47 48 49
boolean_exp          : 11 14 14 15 15 21 44 45 46 47 48 49
comparison_exp       : 20 28
conditional_exp      : 13
echo_exp             : 9
expression           : 6 43
float                : 40
instruction          : 4 5
iterative_exp        : 8
num                  : 36
program              : 0
statement            : 2 3
variable             : 18 37

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . bloc
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    program                        shift and go to state 1
    bloc                           shift and go to state 2
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    boolean_exp                    shift and go to state 9
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 1

    (0) S' -> program .



state 2

    (1) program -> bloc .

    $end            reduce using rule 1 (program -> bloc .)


state 3

    (2) bloc -> statement . bloc
    (3) bloc -> statement .
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ECHO resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
    $end            reduce using rule 3 (bloc -> statement .)
    SEMICOLON       reduce using rule 3 (bloc -> statement .)
    END             reduce using rule 3 (bloc -> statement .)
    AT              reduce using rule 3 (bloc -> statement .)
    ELSE            reduce using rule 3 (bloc -> statement .)
    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

  ! NAME            [ reduce using rule 3 (bloc -> statement .) ]
  ! FOR             [ reduce using rule 3 (bloc -> statement .) ]
  ! WHILE           [ reduce using rule 3 (bloc -> statement .) ]
  ! ECHO            [ reduce using rule 3 (bloc -> statement .) ]
  ! TRUE            [ reduce using rule 3 (bloc -> statement .) ]
  ! FALSE           [ reduce using rule 3 (bloc -> statement .) ]
  ! STRING          [ reduce using rule 3 (bloc -> statement .) ]
  ! LPAREN          [ reduce using rule 3 (bloc -> statement .) ]
  ! MINUS           [ reduce using rule 3 (bloc -> statement .) ]
  ! IF              [ reduce using rule 3 (bloc -> statement .) ]
  ! NUMBER          [ reduce using rule 3 (bloc -> statement .) ]

    statement                      shift and go to state 3
    bloc                           shift and go to state 27
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    boolean_exp                    shift and go to state 9
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 4

    (4) statement -> instruction . SEMICOLON
    (5) statement -> instruction .

  ! shift/reduce conflict for SEMICOLON resolved as shift
    SEMICOLON       shift and go to state 28
    NAME            reduce using rule 5 (statement -> instruction .)
    FOR             reduce using rule 5 (statement -> instruction .)
    WHILE           reduce using rule 5 (statement -> instruction .)
    ECHO            reduce using rule 5 (statement -> instruction .)
    TRUE            reduce using rule 5 (statement -> instruction .)
    FALSE           reduce using rule 5 (statement -> instruction .)
    STRING          reduce using rule 5 (statement -> instruction .)
    LPAREN          reduce using rule 5 (statement -> instruction .)
    MINUS           reduce using rule 5 (statement -> instruction .)
    IF              reduce using rule 5 (statement -> instruction .)
    NUMBER          reduce using rule 5 (statement -> instruction .)
    $end            reduce using rule 5 (statement -> instruction .)
    END             reduce using rule 5 (statement -> instruction .)
    AT              reduce using rule 5 (statement -> instruction .)
    ELSE            reduce using rule 5 (statement -> instruction .)

  ! SEMICOLON       [ reduce using rule 5 (statement -> instruction .) ]


state 5

    (6) instruction -> expression .

    SEMICOLON       reduce using rule 6 (instruction -> expression .)
    NAME            reduce using rule 6 (instruction -> expression .)
    FOR             reduce using rule 6 (instruction -> expression .)
    WHILE           reduce using rule 6 (instruction -> expression .)
    ECHO            reduce using rule 6 (instruction -> expression .)
    TRUE            reduce using rule 6 (instruction -> expression .)
    FALSE           reduce using rule 6 (instruction -> expression .)
    STRING          reduce using rule 6 (instruction -> expression .)
    LPAREN          reduce using rule 6 (instruction -> expression .)
    MINUS           reduce using rule 6 (instruction -> expression .)
    IF              reduce using rule 6 (instruction -> expression .)
    NUMBER          reduce using rule 6 (instruction -> expression .)
    $end            reduce using rule 6 (instruction -> expression .)
    END             reduce using rule 6 (instruction -> expression .)
    AT              reduce using rule 6 (instruction -> expression .)
    ELSE            reduce using rule 6 (instruction -> expression .)


state 6

    (7) instruction -> assignment .

    SEMICOLON       reduce using rule 7 (instruction -> assignment .)
    NAME            reduce using rule 7 (instruction -> assignment .)
    FOR             reduce using rule 7 (instruction -> assignment .)
    WHILE           reduce using rule 7 (instruction -> assignment .)
    ECHO            reduce using rule 7 (instruction -> assignment .)
    TRUE            reduce using rule 7 (instruction -> assignment .)
    FALSE           reduce using rule 7 (instruction -> assignment .)
    STRING          reduce using rule 7 (instruction -> assignment .)
    LPAREN          reduce using rule 7 (instruction -> assignment .)
    MINUS           reduce using rule 7 (instruction -> assignment .)
    IF              reduce using rule 7 (instruction -> assignment .)
    NUMBER          reduce using rule 7 (instruction -> assignment .)
    $end            reduce using rule 7 (instruction -> assignment .)
    END             reduce using rule 7 (instruction -> assignment .)
    AT              reduce using rule 7 (instruction -> assignment .)
    ELSE            reduce using rule 7 (instruction -> assignment .)


state 7

    (8) instruction -> iterative_exp .

    SEMICOLON       reduce using rule 8 (instruction -> iterative_exp .)
    NAME            reduce using rule 8 (instruction -> iterative_exp .)
    FOR             reduce using rule 8 (instruction -> iterative_exp .)
    WHILE           reduce using rule 8 (instruction -> iterative_exp .)
    ECHO            reduce using rule 8 (instruction -> iterative_exp .)
    TRUE            reduce using rule 8 (instruction -> iterative_exp .)
    FALSE           reduce using rule 8 (instruction -> iterative_exp .)
    STRING          reduce using rule 8 (instruction -> iterative_exp .)
    LPAREN          reduce using rule 8 (instruction -> iterative_exp .)
    MINUS           reduce using rule 8 (instruction -> iterative_exp .)
    IF              reduce using rule 8 (instruction -> iterative_exp .)
    NUMBER          reduce using rule 8 (instruction -> iterative_exp .)
    $end            reduce using rule 8 (instruction -> iterative_exp .)
    END             reduce using rule 8 (instruction -> iterative_exp .)
    AT              reduce using rule 8 (instruction -> iterative_exp .)
    ELSE            reduce using rule 8 (instruction -> iterative_exp .)


state 8

    (9) instruction -> echo_exp .

    SEMICOLON       reduce using rule 9 (instruction -> echo_exp .)
    NAME            reduce using rule 9 (instruction -> echo_exp .)
    FOR             reduce using rule 9 (instruction -> echo_exp .)
    WHILE           reduce using rule 9 (instruction -> echo_exp .)
    ECHO            reduce using rule 9 (instruction -> echo_exp .)
    TRUE            reduce using rule 9 (instruction -> echo_exp .)
    FALSE           reduce using rule 9 (instruction -> echo_exp .)
    STRING          reduce using rule 9 (instruction -> echo_exp .)
    LPAREN          reduce using rule 9 (instruction -> echo_exp .)
    MINUS           reduce using rule 9 (instruction -> echo_exp .)
    IF              reduce using rule 9 (instruction -> echo_exp .)
    NUMBER          reduce using rule 9 (instruction -> echo_exp .)
    $end            reduce using rule 9 (instruction -> echo_exp .)
    END             reduce using rule 9 (instruction -> echo_exp .)
    AT              reduce using rule 9 (instruction -> echo_exp .)
    ELSE            reduce using rule 9 (instruction -> echo_exp .)


state 9

    (11) expression -> boolean_exp .
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

    SEMICOLON       reduce using rule 11 (expression -> boolean_exp .)
    NAME            reduce using rule 11 (expression -> boolean_exp .)
    FOR             reduce using rule 11 (expression -> boolean_exp .)
    WHILE           reduce using rule 11 (expression -> boolean_exp .)
    ECHO            reduce using rule 11 (expression -> boolean_exp .)
    TRUE            reduce using rule 11 (expression -> boolean_exp .)
    FALSE           reduce using rule 11 (expression -> boolean_exp .)
    STRING          reduce using rule 11 (expression -> boolean_exp .)
    LPAREN          reduce using rule 11 (expression -> boolean_exp .)
    MINUS           reduce using rule 11 (expression -> boolean_exp .)
    IF              reduce using rule 11 (expression -> boolean_exp .)
    NUMBER          reduce using rule 11 (expression -> boolean_exp .)
    $end            reduce using rule 11 (expression -> boolean_exp .)
    END             reduce using rule 11 (expression -> boolean_exp .)
    AT              reduce using rule 11 (expression -> boolean_exp .)
    ELSE            reduce using rule 11 (expression -> boolean_exp .)
    AND             shift and go to state 29
    OR              shift and go to state 30


state 10

    (12) expression -> arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp
    (22) comparison_exp -> arithmetic_exp . IS_BIGGER arithmetic_exp
    (23) comparison_exp -> arithmetic_exp . IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> arithmetic_exp . IS_SMALLER arithmetic_exp
    (25) comparison_exp -> arithmetic_exp . IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> arithmetic_exp . IS_EQUALS arithmetic_exp
    (27) comparison_exp -> arithmetic_exp . IS_DIFFERENT arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    SEMICOLON       reduce using rule 12 (expression -> arithmetic_exp .)
    NAME            reduce using rule 12 (expression -> arithmetic_exp .)
    FOR             reduce using rule 12 (expression -> arithmetic_exp .)
    WHILE           reduce using rule 12 (expression -> arithmetic_exp .)
    ECHO            reduce using rule 12 (expression -> arithmetic_exp .)
    TRUE            reduce using rule 12 (expression -> arithmetic_exp .)
    FALSE           reduce using rule 12 (expression -> arithmetic_exp .)
    STRING          reduce using rule 12 (expression -> arithmetic_exp .)
    LPAREN          reduce using rule 12 (expression -> arithmetic_exp .)
    IF              reduce using rule 12 (expression -> arithmetic_exp .)
    NUMBER          reduce using rule 12 (expression -> arithmetic_exp .)
    $end            reduce using rule 12 (expression -> arithmetic_exp .)
    END             reduce using rule 12 (expression -> arithmetic_exp .)
    AT              reduce using rule 12 (expression -> arithmetic_exp .)
    ELSE            reduce using rule 12 (expression -> arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    IS_BIGGER       shift and go to state 36
    IS_BIGGER_EQUALS shift and go to state 37
    IS_SMALLER      shift and go to state 38
    IS_SMALLER_EQUALS shift and go to state 39
    IS_EQUALS       shift and go to state 40
    IS_DIFFERENT    shift and go to state 41

  ! MINUS           [ reduce using rule 12 (expression -> arithmetic_exp .) ]


state 11

    (13) expression -> conditional_exp .

    SEMICOLON       reduce using rule 13 (expression -> conditional_exp .)
    NAME            reduce using rule 13 (expression -> conditional_exp .)
    FOR             reduce using rule 13 (expression -> conditional_exp .)
    WHILE           reduce using rule 13 (expression -> conditional_exp .)
    ECHO            reduce using rule 13 (expression -> conditional_exp .)
    TRUE            reduce using rule 13 (expression -> conditional_exp .)
    FALSE           reduce using rule 13 (expression -> conditional_exp .)
    STRING          reduce using rule 13 (expression -> conditional_exp .)
    LPAREN          reduce using rule 13 (expression -> conditional_exp .)
    MINUS           reduce using rule 13 (expression -> conditional_exp .)
    IF              reduce using rule 13 (expression -> conditional_exp .)
    NUMBER          reduce using rule 13 (expression -> conditional_exp .)
    $end            reduce using rule 13 (expression -> conditional_exp .)
    END             reduce using rule 13 (expression -> conditional_exp .)
    AT              reduce using rule 13 (expression -> conditional_exp .)
    ELSE            reduce using rule 13 (expression -> conditional_exp .)


state 12

    (43) assignment -> NAME . EQUALS expression
    (42) variable -> NAME .

    EQUALS          shift and go to state 42
    AND             reduce using rule 42 (variable -> NAME .)
    OR              reduce using rule 42 (variable -> NAME .)
    SEMICOLON       reduce using rule 42 (variable -> NAME .)
    NAME            reduce using rule 42 (variable -> NAME .)
    FOR             reduce using rule 42 (variable -> NAME .)
    WHILE           reduce using rule 42 (variable -> NAME .)
    ECHO            reduce using rule 42 (variable -> NAME .)
    TRUE            reduce using rule 42 (variable -> NAME .)
    FALSE           reduce using rule 42 (variable -> NAME .)
    STRING          reduce using rule 42 (variable -> NAME .)
    LPAREN          reduce using rule 42 (variable -> NAME .)
    MINUS           reduce using rule 42 (variable -> NAME .)
    IF              reduce using rule 42 (variable -> NAME .)
    NUMBER          reduce using rule 42 (variable -> NAME .)
    $end            reduce using rule 42 (variable -> NAME .)
    PLUS            reduce using rule 42 (variable -> NAME .)
    TIMES           reduce using rule 42 (variable -> NAME .)
    DIVIDE          reduce using rule 42 (variable -> NAME .)
    MODULO          reduce using rule 42 (variable -> NAME .)
    IS_BIGGER       reduce using rule 42 (variable -> NAME .)
    IS_BIGGER_EQUALS reduce using rule 42 (variable -> NAME .)
    IS_SMALLER      reduce using rule 42 (variable -> NAME .)
    IS_SMALLER_EQUALS reduce using rule 42 (variable -> NAME .)
    IS_EQUALS       reduce using rule 42 (variable -> NAME .)
    IS_DIFFERENT    reduce using rule 42 (variable -> NAME .)
    END             reduce using rule 42 (variable -> NAME .)
    AT              reduce using rule 42 (variable -> NAME .)
    ELSE            reduce using rule 42 (variable -> NAME .)


state 13

    (46) iterative_exp -> FOR . assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> FOR . assignment boolean_exp bloc AT bloc END
    (43) assignment -> . NAME EQUALS expression

    NAME            shift and go to state 44

    assignment                     shift and go to state 43

state 14

    (48) iterative_exp -> WHILE . boolean_exp AT bloc END
    (49) iterative_exp -> WHILE . boolean_exp bloc END
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 45
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 15

    (10) echo_exp -> ECHO . bloc
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    bloc                           shift and go to state 49
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    boolean_exp                    shift and go to state 9
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 16

    (16) boolean_exp -> TRUE .

    AND             reduce using rule 16 (boolean_exp -> TRUE .)
    OR              reduce using rule 16 (boolean_exp -> TRUE .)
    SEMICOLON       reduce using rule 16 (boolean_exp -> TRUE .)
    NAME            reduce using rule 16 (boolean_exp -> TRUE .)
    FOR             reduce using rule 16 (boolean_exp -> TRUE .)
    WHILE           reduce using rule 16 (boolean_exp -> TRUE .)
    ECHO            reduce using rule 16 (boolean_exp -> TRUE .)
    TRUE            reduce using rule 16 (boolean_exp -> TRUE .)
    FALSE           reduce using rule 16 (boolean_exp -> TRUE .)
    STRING          reduce using rule 16 (boolean_exp -> TRUE .)
    LPAREN          reduce using rule 16 (boolean_exp -> TRUE .)
    MINUS           reduce using rule 16 (boolean_exp -> TRUE .)
    IF              reduce using rule 16 (boolean_exp -> TRUE .)
    NUMBER          reduce using rule 16 (boolean_exp -> TRUE .)
    $end            reduce using rule 16 (boolean_exp -> TRUE .)
    END             reduce using rule 16 (boolean_exp -> TRUE .)
    AT              reduce using rule 16 (boolean_exp -> TRUE .)
    ELSE            reduce using rule 16 (boolean_exp -> TRUE .)
    RPAREN          reduce using rule 16 (boolean_exp -> TRUE .)


state 17

    (17) boolean_exp -> FALSE .

    AND             reduce using rule 17 (boolean_exp -> FALSE .)
    OR              reduce using rule 17 (boolean_exp -> FALSE .)
    SEMICOLON       reduce using rule 17 (boolean_exp -> FALSE .)
    NAME            reduce using rule 17 (boolean_exp -> FALSE .)
    FOR             reduce using rule 17 (boolean_exp -> FALSE .)
    WHILE           reduce using rule 17 (boolean_exp -> FALSE .)
    ECHO            reduce using rule 17 (boolean_exp -> FALSE .)
    TRUE            reduce using rule 17 (boolean_exp -> FALSE .)
    FALSE           reduce using rule 17 (boolean_exp -> FALSE .)
    STRING          reduce using rule 17 (boolean_exp -> FALSE .)
    LPAREN          reduce using rule 17 (boolean_exp -> FALSE .)
    MINUS           reduce using rule 17 (boolean_exp -> FALSE .)
    IF              reduce using rule 17 (boolean_exp -> FALSE .)
    NUMBER          reduce using rule 17 (boolean_exp -> FALSE .)
    $end            reduce using rule 17 (boolean_exp -> FALSE .)
    END             reduce using rule 17 (boolean_exp -> FALSE .)
    AT              reduce using rule 17 (boolean_exp -> FALSE .)
    ELSE            reduce using rule 17 (boolean_exp -> FALSE .)
    RPAREN          reduce using rule 17 (boolean_exp -> FALSE .)


state 18

    (18) boolean_exp -> variable .
    (37) arithmetic_exp -> variable .

  ! reduce/reduce conflict for MINUS resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for NAME resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for FOR resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for WHILE resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for ECHO resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for TRUE resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for FALSE resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for STRING resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for LPAREN resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for IF resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for NUMBER resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for $end resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for END resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for AT resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for ELSE resolved using rule 18 (boolean_exp -> variable .)
  ! reduce/reduce conflict for RPAREN resolved using rule 18 (boolean_exp -> variable .)
    AND             reduce using rule 18 (boolean_exp -> variable .)
    OR              reduce using rule 18 (boolean_exp -> variable .)
    SEMICOLON       reduce using rule 18 (boolean_exp -> variable .)
    NAME            reduce using rule 18 (boolean_exp -> variable .)
    FOR             reduce using rule 18 (boolean_exp -> variable .)
    WHILE           reduce using rule 18 (boolean_exp -> variable .)
    ECHO            reduce using rule 18 (boolean_exp -> variable .)
    TRUE            reduce using rule 18 (boolean_exp -> variable .)
    FALSE           reduce using rule 18 (boolean_exp -> variable .)
    STRING          reduce using rule 18 (boolean_exp -> variable .)
    LPAREN          reduce using rule 18 (boolean_exp -> variable .)
    MINUS           reduce using rule 18 (boolean_exp -> variable .)
    IF              reduce using rule 18 (boolean_exp -> variable .)
    NUMBER          reduce using rule 18 (boolean_exp -> variable .)
    $end            reduce using rule 18 (boolean_exp -> variable .)
    END             reduce using rule 18 (boolean_exp -> variable .)
    AT              reduce using rule 18 (boolean_exp -> variable .)
    ELSE            reduce using rule 18 (boolean_exp -> variable .)
    RPAREN          reduce using rule 18 (boolean_exp -> variable .)
    PLUS            reduce using rule 37 (arithmetic_exp -> variable .)
    TIMES           reduce using rule 37 (arithmetic_exp -> variable .)
    DIVIDE          reduce using rule 37 (arithmetic_exp -> variable .)
    MODULO          reduce using rule 37 (arithmetic_exp -> variable .)
    IS_BIGGER       reduce using rule 37 (arithmetic_exp -> variable .)
    IS_BIGGER_EQUALS reduce using rule 37 (arithmetic_exp -> variable .)
    IS_SMALLER      reduce using rule 37 (arithmetic_exp -> variable .)
    IS_SMALLER_EQUALS reduce using rule 37 (arithmetic_exp -> variable .)
    IS_EQUALS       reduce using rule 37 (arithmetic_exp -> variable .)
    IS_DIFFERENT    reduce using rule 37 (arithmetic_exp -> variable .)

  ! MINUS           [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! SEMICOLON       [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! NAME            [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! FOR             [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! WHILE           [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! ECHO            [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! TRUE            [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! FALSE           [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! STRING          [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! LPAREN          [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! IF              [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! NUMBER          [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! $end            [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! END             [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! AT              [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! ELSE            [ reduce using rule 37 (arithmetic_exp -> variable .) ]
  ! RPAREN          [ reduce using rule 37 (arithmetic_exp -> variable .) ]


state 19

    (19) boolean_exp -> STRING .
    (38) arithmetic_exp -> STRING .

  ! reduce/reduce conflict for MINUS resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for NAME resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for ECHO resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for STRING resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for IF resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for NUMBER resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for $end resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for END resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for AT resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (boolean_exp -> STRING .)
  ! reduce/reduce conflict for RPAREN resolved using rule 19 (boolean_exp -> STRING .)
    AND             reduce using rule 19 (boolean_exp -> STRING .)
    OR              reduce using rule 19 (boolean_exp -> STRING .)
    SEMICOLON       reduce using rule 19 (boolean_exp -> STRING .)
    NAME            reduce using rule 19 (boolean_exp -> STRING .)
    FOR             reduce using rule 19 (boolean_exp -> STRING .)
    WHILE           reduce using rule 19 (boolean_exp -> STRING .)
    ECHO            reduce using rule 19 (boolean_exp -> STRING .)
    TRUE            reduce using rule 19 (boolean_exp -> STRING .)
    FALSE           reduce using rule 19 (boolean_exp -> STRING .)
    STRING          reduce using rule 19 (boolean_exp -> STRING .)
    LPAREN          reduce using rule 19 (boolean_exp -> STRING .)
    MINUS           reduce using rule 19 (boolean_exp -> STRING .)
    IF              reduce using rule 19 (boolean_exp -> STRING .)
    NUMBER          reduce using rule 19 (boolean_exp -> STRING .)
    $end            reduce using rule 19 (boolean_exp -> STRING .)
    END             reduce using rule 19 (boolean_exp -> STRING .)
    AT              reduce using rule 19 (boolean_exp -> STRING .)
    ELSE            reduce using rule 19 (boolean_exp -> STRING .)
    RPAREN          reduce using rule 19 (boolean_exp -> STRING .)
    PLUS            reduce using rule 38 (arithmetic_exp -> STRING .)
    TIMES           reduce using rule 38 (arithmetic_exp -> STRING .)
    DIVIDE          reduce using rule 38 (arithmetic_exp -> STRING .)
    MODULO          reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_BIGGER       reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_BIGGER_EQUALS reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_SMALLER      reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_SMALLER_EQUALS reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_EQUALS       reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_DIFFERENT    reduce using rule 38 (arithmetic_exp -> STRING .)

  ! MINUS           [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! SEMICOLON       [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! NAME            [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! FOR             [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! WHILE           [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! ECHO            [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! TRUE            [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! FALSE           [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! STRING          [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! LPAREN          [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! IF              [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! NUMBER          [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! $end            [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! END             [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! AT              [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! ELSE            [ reduce using rule 38 (arithmetic_exp -> STRING .) ]
  ! RPAREN          [ reduce using rule 38 (arithmetic_exp -> STRING .) ]


state 20

    (20) boolean_exp -> comparison_exp .

    AND             reduce using rule 20 (boolean_exp -> comparison_exp .)
    OR              reduce using rule 20 (boolean_exp -> comparison_exp .)
    SEMICOLON       reduce using rule 20 (boolean_exp -> comparison_exp .)
    NAME            reduce using rule 20 (boolean_exp -> comparison_exp .)
    FOR             reduce using rule 20 (boolean_exp -> comparison_exp .)
    WHILE           reduce using rule 20 (boolean_exp -> comparison_exp .)
    ECHO            reduce using rule 20 (boolean_exp -> comparison_exp .)
    TRUE            reduce using rule 20 (boolean_exp -> comparison_exp .)
    FALSE           reduce using rule 20 (boolean_exp -> comparison_exp .)
    STRING          reduce using rule 20 (boolean_exp -> comparison_exp .)
    LPAREN          reduce using rule 20 (boolean_exp -> comparison_exp .)
    MINUS           reduce using rule 20 (boolean_exp -> comparison_exp .)
    IF              reduce using rule 20 (boolean_exp -> comparison_exp .)
    NUMBER          reduce using rule 20 (boolean_exp -> comparison_exp .)
    $end            reduce using rule 20 (boolean_exp -> comparison_exp .)
    END             reduce using rule 20 (boolean_exp -> comparison_exp .)
    AT              reduce using rule 20 (boolean_exp -> comparison_exp .)
    ELSE            reduce using rule 20 (boolean_exp -> comparison_exp .)
    RPAREN          reduce using rule 20 (boolean_exp -> comparison_exp .)


state 21

    (21) boolean_exp -> LPAREN . boolean_exp RPAREN
    (34) arithmetic_exp -> LPAREN . arithmetic_exp RPAREN
    (28) comparison_exp -> LPAREN . comparison_exp RPAREN
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (42) variable -> . NAME
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    NAME            shift and go to state 47
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 50
    arithmetic_exp                 shift and go to state 51
    comparison_exp                 shift and go to state 52
    variable                       shift and go to state 18
    num                            shift and go to state 23
    float                          shift and go to state 26

state 22

    (35) arithmetic_exp -> MINUS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 53
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 23

    (36) arithmetic_exp -> num .

    PLUS            reduce using rule 36 (arithmetic_exp -> num .)
    MINUS           reduce using rule 36 (arithmetic_exp -> num .)
    TIMES           reduce using rule 36 (arithmetic_exp -> num .)
    DIVIDE          reduce using rule 36 (arithmetic_exp -> num .)
    MODULO          reduce using rule 36 (arithmetic_exp -> num .)
    IS_BIGGER       reduce using rule 36 (arithmetic_exp -> num .)
    IS_BIGGER_EQUALS reduce using rule 36 (arithmetic_exp -> num .)
    IS_SMALLER      reduce using rule 36 (arithmetic_exp -> num .)
    IS_SMALLER_EQUALS reduce using rule 36 (arithmetic_exp -> num .)
    IS_EQUALS       reduce using rule 36 (arithmetic_exp -> num .)
    IS_DIFFERENT    reduce using rule 36 (arithmetic_exp -> num .)
    SEMICOLON       reduce using rule 36 (arithmetic_exp -> num .)
    NAME            reduce using rule 36 (arithmetic_exp -> num .)
    FOR             reduce using rule 36 (arithmetic_exp -> num .)
    WHILE           reduce using rule 36 (arithmetic_exp -> num .)
    ECHO            reduce using rule 36 (arithmetic_exp -> num .)
    TRUE            reduce using rule 36 (arithmetic_exp -> num .)
    FALSE           reduce using rule 36 (arithmetic_exp -> num .)
    STRING          reduce using rule 36 (arithmetic_exp -> num .)
    LPAREN          reduce using rule 36 (arithmetic_exp -> num .)
    IF              reduce using rule 36 (arithmetic_exp -> num .)
    NUMBER          reduce using rule 36 (arithmetic_exp -> num .)
    $end            reduce using rule 36 (arithmetic_exp -> num .)
    END             reduce using rule 36 (arithmetic_exp -> num .)
    AT              reduce using rule 36 (arithmetic_exp -> num .)
    ELSE            reduce using rule 36 (arithmetic_exp -> num .)
    RPAREN          reduce using rule 36 (arithmetic_exp -> num .)
    AND             reduce using rule 36 (arithmetic_exp -> num .)
    OR              reduce using rule 36 (arithmetic_exp -> num .)


state 24

    (44) conditional_exp -> IF . boolean_exp AT bloc END
    (45) conditional_exp -> IF . boolean_exp AT bloc ELSE bloc END
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 57
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 25

    (39) num -> NUMBER .
    (41) float -> NUMBER . DOT NUMBER

    PLUS            reduce using rule 39 (num -> NUMBER .)
    MINUS           reduce using rule 39 (num -> NUMBER .)
    TIMES           reduce using rule 39 (num -> NUMBER .)
    DIVIDE          reduce using rule 39 (num -> NUMBER .)
    MODULO          reduce using rule 39 (num -> NUMBER .)
    IS_BIGGER       reduce using rule 39 (num -> NUMBER .)
    IS_BIGGER_EQUALS reduce using rule 39 (num -> NUMBER .)
    IS_SMALLER      reduce using rule 39 (num -> NUMBER .)
    IS_SMALLER_EQUALS reduce using rule 39 (num -> NUMBER .)
    IS_EQUALS       reduce using rule 39 (num -> NUMBER .)
    IS_DIFFERENT    reduce using rule 39 (num -> NUMBER .)
    SEMICOLON       reduce using rule 39 (num -> NUMBER .)
    NAME            reduce using rule 39 (num -> NUMBER .)
    FOR             reduce using rule 39 (num -> NUMBER .)
    WHILE           reduce using rule 39 (num -> NUMBER .)
    ECHO            reduce using rule 39 (num -> NUMBER .)
    TRUE            reduce using rule 39 (num -> NUMBER .)
    FALSE           reduce using rule 39 (num -> NUMBER .)
    STRING          reduce using rule 39 (num -> NUMBER .)
    LPAREN          reduce using rule 39 (num -> NUMBER .)
    IF              reduce using rule 39 (num -> NUMBER .)
    NUMBER          reduce using rule 39 (num -> NUMBER .)
    $end            reduce using rule 39 (num -> NUMBER .)
    END             reduce using rule 39 (num -> NUMBER .)
    AT              reduce using rule 39 (num -> NUMBER .)
    ELSE            reduce using rule 39 (num -> NUMBER .)
    RPAREN          reduce using rule 39 (num -> NUMBER .)
    AND             reduce using rule 39 (num -> NUMBER .)
    OR              reduce using rule 39 (num -> NUMBER .)
    DOT             shift and go to state 58


state 26

    (40) num -> float .

    PLUS            reduce using rule 40 (num -> float .)
    MINUS           reduce using rule 40 (num -> float .)
    TIMES           reduce using rule 40 (num -> float .)
    DIVIDE          reduce using rule 40 (num -> float .)
    MODULO          reduce using rule 40 (num -> float .)
    IS_BIGGER       reduce using rule 40 (num -> float .)
    IS_BIGGER_EQUALS reduce using rule 40 (num -> float .)
    IS_SMALLER      reduce using rule 40 (num -> float .)
    IS_SMALLER_EQUALS reduce using rule 40 (num -> float .)
    IS_EQUALS       reduce using rule 40 (num -> float .)
    IS_DIFFERENT    reduce using rule 40 (num -> float .)
    SEMICOLON       reduce using rule 40 (num -> float .)
    NAME            reduce using rule 40 (num -> float .)
    FOR             reduce using rule 40 (num -> float .)
    WHILE           reduce using rule 40 (num -> float .)
    ECHO            reduce using rule 40 (num -> float .)
    TRUE            reduce using rule 40 (num -> float .)
    FALSE           reduce using rule 40 (num -> float .)
    STRING          reduce using rule 40 (num -> float .)
    LPAREN          reduce using rule 40 (num -> float .)
    IF              reduce using rule 40 (num -> float .)
    NUMBER          reduce using rule 40 (num -> float .)
    $end            reduce using rule 40 (num -> float .)
    END             reduce using rule 40 (num -> float .)
    AT              reduce using rule 40 (num -> float .)
    ELSE            reduce using rule 40 (num -> float .)
    RPAREN          reduce using rule 40 (num -> float .)
    AND             reduce using rule 40 (num -> float .)
    OR              reduce using rule 40 (num -> float .)


state 27

    (2) bloc -> statement bloc .

    $end            reduce using rule 2 (bloc -> statement bloc .)
    SEMICOLON       reduce using rule 2 (bloc -> statement bloc .)
    NAME            reduce using rule 2 (bloc -> statement bloc .)
    FOR             reduce using rule 2 (bloc -> statement bloc .)
    WHILE           reduce using rule 2 (bloc -> statement bloc .)
    ECHO            reduce using rule 2 (bloc -> statement bloc .)
    TRUE            reduce using rule 2 (bloc -> statement bloc .)
    FALSE           reduce using rule 2 (bloc -> statement bloc .)
    STRING          reduce using rule 2 (bloc -> statement bloc .)
    LPAREN          reduce using rule 2 (bloc -> statement bloc .)
    MINUS           reduce using rule 2 (bloc -> statement bloc .)
    IF              reduce using rule 2 (bloc -> statement bloc .)
    NUMBER          reduce using rule 2 (bloc -> statement bloc .)
    END             reduce using rule 2 (bloc -> statement bloc .)
    AT              reduce using rule 2 (bloc -> statement bloc .)
    ELSE            reduce using rule 2 (bloc -> statement bloc .)


state 28

    (4) statement -> instruction SEMICOLON .

    NAME            reduce using rule 4 (statement -> instruction SEMICOLON .)
    FOR             reduce using rule 4 (statement -> instruction SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> instruction SEMICOLON .)
    ECHO            reduce using rule 4 (statement -> instruction SEMICOLON .)
    TRUE            reduce using rule 4 (statement -> instruction SEMICOLON .)
    FALSE           reduce using rule 4 (statement -> instruction SEMICOLON .)
    STRING          reduce using rule 4 (statement -> instruction SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> instruction SEMICOLON .)
    MINUS           reduce using rule 4 (statement -> instruction SEMICOLON .)
    IF              reduce using rule 4 (statement -> instruction SEMICOLON .)
    NUMBER          reduce using rule 4 (statement -> instruction SEMICOLON .)
    $end            reduce using rule 4 (statement -> instruction SEMICOLON .)
    SEMICOLON       reduce using rule 4 (statement -> instruction SEMICOLON .)
    END             reduce using rule 4 (statement -> instruction SEMICOLON .)
    AT              reduce using rule 4 (statement -> instruction SEMICOLON .)
    ELSE            reduce using rule 4 (statement -> instruction SEMICOLON .)


state 29

    (14) boolean_exp -> boolean_exp AND . boolean_exp
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 59
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 30

    (15) boolean_exp -> boolean_exp OR . boolean_exp
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 60
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 31

    (29) arithmetic_exp -> arithmetic_exp PLUS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 61
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 32

    (30) arithmetic_exp -> arithmetic_exp MINUS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 62
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 33

    (31) arithmetic_exp -> arithmetic_exp TIMES . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 63
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 34

    (32) arithmetic_exp -> arithmetic_exp DIVIDE . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 64
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 35

    (33) arithmetic_exp -> arithmetic_exp MODULO . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 65
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 36

    (22) comparison_exp -> arithmetic_exp IS_BIGGER . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 66
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 37

    (23) comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 67
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 38

    (24) comparison_exp -> arithmetic_exp IS_SMALLER . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 68
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 39

    (25) comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 69
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 40

    (26) comparison_exp -> arithmetic_exp IS_EQUALS . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 70
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 41

    (27) comparison_exp -> arithmetic_exp IS_DIFFERENT . arithmetic_exp
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 71
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 42

    (43) assignment -> NAME EQUALS . expression
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NAME            shift and go to state 47
    NUMBER          shift and go to state 25

    expression                     shift and go to state 72
    boolean_exp                    shift and go to state 9
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 43

    (46) iterative_exp -> FOR assignment . AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> FOR assignment . boolean_exp bloc AT bloc END
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    AT              shift and go to state 73
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 74
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 44

    (43) assignment -> NAME . EQUALS expression

    EQUALS          shift and go to state 42


state 45

    (48) iterative_exp -> WHILE boolean_exp . AT bloc END
    (49) iterative_exp -> WHILE boolean_exp . bloc END
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    AT              shift and go to state 75
    AND             shift and go to state 29
    OR              shift and go to state 30
    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 76
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 46

    (21) boolean_exp -> LPAREN . boolean_exp RPAREN
    (28) comparison_exp -> LPAREN . comparison_exp RPAREN
    (34) arithmetic_exp -> LPAREN . arithmetic_exp RPAREN
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (42) variable -> . NAME
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    MINUS           shift and go to state 22
    NAME            shift and go to state 47
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 50
    comparison_exp                 shift and go to state 52
    arithmetic_exp                 shift and go to state 77
    variable                       shift and go to state 18
    num                            shift and go to state 23
    float                          shift and go to state 26

state 47

    (42) variable -> NAME .

    AT              reduce using rule 42 (variable -> NAME .)
    AND             reduce using rule 42 (variable -> NAME .)
    OR              reduce using rule 42 (variable -> NAME .)
    NAME            reduce using rule 42 (variable -> NAME .)
    FOR             reduce using rule 42 (variable -> NAME .)
    WHILE           reduce using rule 42 (variable -> NAME .)
    ECHO            reduce using rule 42 (variable -> NAME .)
    TRUE            reduce using rule 42 (variable -> NAME .)
    FALSE           reduce using rule 42 (variable -> NAME .)
    STRING          reduce using rule 42 (variable -> NAME .)
    LPAREN          reduce using rule 42 (variable -> NAME .)
    MINUS           reduce using rule 42 (variable -> NAME .)
    IF              reduce using rule 42 (variable -> NAME .)
    NUMBER          reduce using rule 42 (variable -> NAME .)
    IS_BIGGER       reduce using rule 42 (variable -> NAME .)
    IS_BIGGER_EQUALS reduce using rule 42 (variable -> NAME .)
    IS_SMALLER      reduce using rule 42 (variable -> NAME .)
    IS_SMALLER_EQUALS reduce using rule 42 (variable -> NAME .)
    IS_EQUALS       reduce using rule 42 (variable -> NAME .)
    IS_DIFFERENT    reduce using rule 42 (variable -> NAME .)
    PLUS            reduce using rule 42 (variable -> NAME .)
    TIMES           reduce using rule 42 (variable -> NAME .)
    DIVIDE          reduce using rule 42 (variable -> NAME .)
    MODULO          reduce using rule 42 (variable -> NAME .)
    RPAREN          reduce using rule 42 (variable -> NAME .)
    SEMICOLON       reduce using rule 42 (variable -> NAME .)
    $end            reduce using rule 42 (variable -> NAME .)
    END             reduce using rule 42 (variable -> NAME .)
    ELSE            reduce using rule 42 (variable -> NAME .)


state 48

    (22) comparison_exp -> arithmetic_exp . IS_BIGGER arithmetic_exp
    (23) comparison_exp -> arithmetic_exp . IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> arithmetic_exp . IS_SMALLER arithmetic_exp
    (25) comparison_exp -> arithmetic_exp . IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> arithmetic_exp . IS_EQUALS arithmetic_exp
    (27) comparison_exp -> arithmetic_exp . IS_DIFFERENT arithmetic_exp
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    IS_BIGGER       shift and go to state 36
    IS_BIGGER_EQUALS shift and go to state 37
    IS_SMALLER      shift and go to state 38
    IS_SMALLER_EQUALS shift and go to state 39
    IS_EQUALS       shift and go to state 40
    IS_DIFFERENT    shift and go to state 41
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35


state 49

    (10) echo_exp -> ECHO bloc .

    SEMICOLON       reduce using rule 10 (echo_exp -> ECHO bloc .)
    NAME            reduce using rule 10 (echo_exp -> ECHO bloc .)
    FOR             reduce using rule 10 (echo_exp -> ECHO bloc .)
    WHILE           reduce using rule 10 (echo_exp -> ECHO bloc .)
    ECHO            reduce using rule 10 (echo_exp -> ECHO bloc .)
    TRUE            reduce using rule 10 (echo_exp -> ECHO bloc .)
    FALSE           reduce using rule 10 (echo_exp -> ECHO bloc .)
    STRING          reduce using rule 10 (echo_exp -> ECHO bloc .)
    LPAREN          reduce using rule 10 (echo_exp -> ECHO bloc .)
    MINUS           reduce using rule 10 (echo_exp -> ECHO bloc .)
    IF              reduce using rule 10 (echo_exp -> ECHO bloc .)
    NUMBER          reduce using rule 10 (echo_exp -> ECHO bloc .)
    $end            reduce using rule 10 (echo_exp -> ECHO bloc .)
    END             reduce using rule 10 (echo_exp -> ECHO bloc .)
    AT              reduce using rule 10 (echo_exp -> ECHO bloc .)
    ELSE            reduce using rule 10 (echo_exp -> ECHO bloc .)


state 50

    (21) boolean_exp -> LPAREN boolean_exp . RPAREN
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

    RPAREN          shift and go to state 78
    AND             shift and go to state 29
    OR              shift and go to state 30


state 51

    (34) arithmetic_exp -> LPAREN arithmetic_exp . RPAREN
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp
    (22) comparison_exp -> arithmetic_exp . IS_BIGGER arithmetic_exp
    (23) comparison_exp -> arithmetic_exp . IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> arithmetic_exp . IS_SMALLER arithmetic_exp
    (25) comparison_exp -> arithmetic_exp . IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> arithmetic_exp . IS_EQUALS arithmetic_exp
    (27) comparison_exp -> arithmetic_exp . IS_DIFFERENT arithmetic_exp

    RPAREN          shift and go to state 79
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35
    IS_BIGGER       shift and go to state 36
    IS_BIGGER_EQUALS shift and go to state 37
    IS_SMALLER      shift and go to state 38
    IS_SMALLER_EQUALS shift and go to state 39
    IS_EQUALS       shift and go to state 40
    IS_DIFFERENT    shift and go to state 41


state 52

    (28) comparison_exp -> LPAREN comparison_exp . RPAREN
    (20) boolean_exp -> comparison_exp .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 80
    AND             reduce using rule 20 (boolean_exp -> comparison_exp .)
    OR              reduce using rule 20 (boolean_exp -> comparison_exp .)

  ! RPAREN          [ reduce using rule 20 (boolean_exp -> comparison_exp .) ]


state 53

    (35) arithmetic_exp -> MINUS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    PLUS            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    MINUS           reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    TIMES           reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    DIVIDE          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    MODULO          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_BIGGER       reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_SMALLER      reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_EQUALS       reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    SEMICOLON       reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    NAME            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    FOR             reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    WHILE           reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    ECHO            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    TRUE            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    FALSE           reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    STRING          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    LPAREN          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    IF              reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    NUMBER          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    $end            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    END             reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    AT              reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    ELSE            reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    RPAREN          reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    AND             reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)
    OR              reduce using rule 35 (arithmetic_exp -> MINUS arithmetic_exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]


state 54

    (34) arithmetic_exp -> LPAREN . arithmetic_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (42) variable -> . NAME
    (41) float -> . NUMBER DOT NUMBER

    LPAREN          shift and go to state 54
    MINUS           shift and go to state 22
    STRING          shift and go to state 56
    NUMBER          shift and go to state 25
    NAME            shift and go to state 47

    arithmetic_exp                 shift and go to state 81
    num                            shift and go to state 23
    variable                       shift and go to state 55
    float                          shift and go to state 26

state 55

    (37) arithmetic_exp -> variable .

    PLUS            reduce using rule 37 (arithmetic_exp -> variable .)
    MINUS           reduce using rule 37 (arithmetic_exp -> variable .)
    TIMES           reduce using rule 37 (arithmetic_exp -> variable .)
    DIVIDE          reduce using rule 37 (arithmetic_exp -> variable .)
    MODULO          reduce using rule 37 (arithmetic_exp -> variable .)
    IS_BIGGER       reduce using rule 37 (arithmetic_exp -> variable .)
    IS_BIGGER_EQUALS reduce using rule 37 (arithmetic_exp -> variable .)
    IS_SMALLER      reduce using rule 37 (arithmetic_exp -> variable .)
    IS_SMALLER_EQUALS reduce using rule 37 (arithmetic_exp -> variable .)
    IS_EQUALS       reduce using rule 37 (arithmetic_exp -> variable .)
    IS_DIFFERENT    reduce using rule 37 (arithmetic_exp -> variable .)
    SEMICOLON       reduce using rule 37 (arithmetic_exp -> variable .)
    NAME            reduce using rule 37 (arithmetic_exp -> variable .)
    FOR             reduce using rule 37 (arithmetic_exp -> variable .)
    WHILE           reduce using rule 37 (arithmetic_exp -> variable .)
    ECHO            reduce using rule 37 (arithmetic_exp -> variable .)
    TRUE            reduce using rule 37 (arithmetic_exp -> variable .)
    FALSE           reduce using rule 37 (arithmetic_exp -> variable .)
    STRING          reduce using rule 37 (arithmetic_exp -> variable .)
    LPAREN          reduce using rule 37 (arithmetic_exp -> variable .)
    IF              reduce using rule 37 (arithmetic_exp -> variable .)
    NUMBER          reduce using rule 37 (arithmetic_exp -> variable .)
    $end            reduce using rule 37 (arithmetic_exp -> variable .)
    END             reduce using rule 37 (arithmetic_exp -> variable .)
    AT              reduce using rule 37 (arithmetic_exp -> variable .)
    ELSE            reduce using rule 37 (arithmetic_exp -> variable .)
    RPAREN          reduce using rule 37 (arithmetic_exp -> variable .)
    AND             reduce using rule 37 (arithmetic_exp -> variable .)
    OR              reduce using rule 37 (arithmetic_exp -> variable .)


state 56

    (38) arithmetic_exp -> STRING .

    PLUS            reduce using rule 38 (arithmetic_exp -> STRING .)
    MINUS           reduce using rule 38 (arithmetic_exp -> STRING .)
    TIMES           reduce using rule 38 (arithmetic_exp -> STRING .)
    DIVIDE          reduce using rule 38 (arithmetic_exp -> STRING .)
    MODULO          reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_BIGGER       reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_BIGGER_EQUALS reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_SMALLER      reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_SMALLER_EQUALS reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_EQUALS       reduce using rule 38 (arithmetic_exp -> STRING .)
    IS_DIFFERENT    reduce using rule 38 (arithmetic_exp -> STRING .)
    SEMICOLON       reduce using rule 38 (arithmetic_exp -> STRING .)
    NAME            reduce using rule 38 (arithmetic_exp -> STRING .)
    FOR             reduce using rule 38 (arithmetic_exp -> STRING .)
    WHILE           reduce using rule 38 (arithmetic_exp -> STRING .)
    ECHO            reduce using rule 38 (arithmetic_exp -> STRING .)
    TRUE            reduce using rule 38 (arithmetic_exp -> STRING .)
    FALSE           reduce using rule 38 (arithmetic_exp -> STRING .)
    STRING          reduce using rule 38 (arithmetic_exp -> STRING .)
    LPAREN          reduce using rule 38 (arithmetic_exp -> STRING .)
    IF              reduce using rule 38 (arithmetic_exp -> STRING .)
    NUMBER          reduce using rule 38 (arithmetic_exp -> STRING .)
    $end            reduce using rule 38 (arithmetic_exp -> STRING .)
    END             reduce using rule 38 (arithmetic_exp -> STRING .)
    AT              reduce using rule 38 (arithmetic_exp -> STRING .)
    ELSE            reduce using rule 38 (arithmetic_exp -> STRING .)
    RPAREN          reduce using rule 38 (arithmetic_exp -> STRING .)
    AND             reduce using rule 38 (arithmetic_exp -> STRING .)
    OR              reduce using rule 38 (arithmetic_exp -> STRING .)


state 57

    (44) conditional_exp -> IF boolean_exp . AT bloc END
    (45) conditional_exp -> IF boolean_exp . AT bloc ELSE bloc END
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

    AT              shift and go to state 82
    AND             shift and go to state 29
    OR              shift and go to state 30


state 58

    (41) float -> NUMBER DOT . NUMBER

    NUMBER          shift and go to state 83


state 59

    (14) boolean_exp -> boolean_exp AND boolean_exp .
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    NAME            reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    FOR             reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    WHILE           reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    ECHO            reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    TRUE            reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    FALSE           reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    STRING          reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    LPAREN          reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    MINUS           reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    IF              reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    NUMBER          reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    $end            reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    END             reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    AT              reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    ELSE            reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    RPAREN          reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .)
    AND             shift and go to state 29
    OR              shift and go to state 30

  ! AND             [ reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .) ]
  ! OR              [ reduce using rule 14 (boolean_exp -> boolean_exp AND boolean_exp .) ]


state 60

    (15) boolean_exp -> boolean_exp OR boolean_exp .
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    NAME            reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    FOR             reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    WHILE           reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    ECHO            reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    TRUE            reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    FALSE           reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    STRING          reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    LPAREN          reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    MINUS           reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    IF              reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    NUMBER          reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    $end            reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    END             reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    AT              reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    ELSE            reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    RPAREN          reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .)
    AND             shift and go to state 29
    OR              shift and go to state 30

  ! AND             [ reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .) ]
  ! OR              [ reduce using rule 15 (boolean_exp -> boolean_exp OR boolean_exp .) ]


state 61

    (29) arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    PLUS            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    MINUS           reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    MODULO          reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_BIGGER       reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_SMALLER      reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_EQUALS       reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    SEMICOLON       reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    NAME            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    FOR             reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    WHILE           reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    ECHO            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    TRUE            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    FALSE           reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    STRING          reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    LPAREN          reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    IF              reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    NUMBER          reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    $end            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    END             reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    AT              reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    ELSE            reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    RPAREN          reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    AND             reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    OR              reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .)
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .) ]
  ! DIVIDE          [ reduce using rule 29 (arithmetic_exp -> arithmetic_exp PLUS arithmetic_exp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! MODULO          [ shift and go to state 35 ]


state 62

    (30) arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    PLUS            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    MINUS           reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    MODULO          reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_BIGGER       reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_SMALLER      reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_EQUALS       reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    SEMICOLON       reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    NAME            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    FOR             reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    WHILE           reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    ECHO            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    TRUE            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    FALSE           reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    STRING          reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    LPAREN          reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    IF              reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    NUMBER          reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    $end            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    END             reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    AT              reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    ELSE            reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    RPAREN          reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    AND             reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    OR              reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .)
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34

  ! TIMES           [ reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .) ]
  ! DIVIDE          [ reduce using rule 30 (arithmetic_exp -> arithmetic_exp MINUS arithmetic_exp .) ]
  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! MODULO          [ shift and go to state 35 ]


state 63

    (31) arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    PLUS            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    MINUS           reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    TIMES           reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    DIVIDE          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    MODULO          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_BIGGER       reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_SMALLER      reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_EQUALS       reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    SEMICOLON       reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    NAME            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    FOR             reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    WHILE           reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    ECHO            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    TRUE            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    FALSE           reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    STRING          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    LPAREN          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    IF              reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    NUMBER          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    $end            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    END             reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    AT              reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    ELSE            reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    RPAREN          reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    AND             reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)
    OR              reduce using rule 31 (arithmetic_exp -> arithmetic_exp TIMES arithmetic_exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]


state 64

    (32) arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    PLUS            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    MINUS           reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    TIMES           reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    DIVIDE          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    MODULO          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_BIGGER       reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_SMALLER      reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_EQUALS       reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    SEMICOLON       reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    NAME            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    FOR             reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    WHILE           reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    ECHO            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    TRUE            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    FALSE           reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    STRING          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    LPAREN          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    IF              reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    NUMBER          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    $end            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    END             reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    AT              reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    ELSE            reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    RPAREN          reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    AND             reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)
    OR              reduce using rule 32 (arithmetic_exp -> arithmetic_exp DIVIDE arithmetic_exp .)

  ! PLUS            [ shift and go to state 31 ]
  ! MINUS           [ shift and go to state 32 ]
  ! TIMES           [ shift and go to state 33 ]
  ! DIVIDE          [ shift and go to state 34 ]
  ! MODULO          [ shift and go to state 35 ]


state 65

    (33) arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
    IS_BIGGER       reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IS_BIGGER_EQUALS reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IS_SMALLER      reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IS_SMALLER_EQUALS reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IS_EQUALS       reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IS_DIFFERENT    reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    SEMICOLON       reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    NAME            reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    FOR             reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    WHILE           reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    ECHO            reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    TRUE            reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    FALSE           reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    STRING          reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    LPAREN          reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    IF              reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    NUMBER          reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    $end            reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    END             reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    AT              reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    ELSE            reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    RPAREN          reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    AND             reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    OR              reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! PLUS            [ reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .) ]
  ! MINUS           [ reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .) ]
  ! TIMES           [ reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .) ]
  ! DIVIDE          [ reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .) ]
  ! MODULO          [ reduce using rule 33 (arithmetic_exp -> arithmetic_exp MODULO arithmetic_exp .) ]


state 66

    (22) comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    OR              reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    SEMICOLON       reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    NAME            reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    FOR             reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    WHILE           reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    ECHO            reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    TRUE            reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    FALSE           reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    STRING          reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    LPAREN          reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    IF              reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    NUMBER          reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    $end            reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    END             reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    AT              reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    ELSE            reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    RPAREN          reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 22 (comparison_exp -> arithmetic_exp IS_BIGGER arithmetic_exp .) ]


state 67

    (23) comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    OR              reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    SEMICOLON       reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    NAME            reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    FOR             reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    WHILE           reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    ECHO            reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    TRUE            reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    FALSE           reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    STRING          reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    LPAREN          reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    IF              reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    NUMBER          reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    $end            reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    END             reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    AT              reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    ELSE            reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    RPAREN          reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 23 (comparison_exp -> arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp .) ]


state 68

    (24) comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    OR              reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    SEMICOLON       reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    NAME            reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    FOR             reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    WHILE           reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    ECHO            reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    TRUE            reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    FALSE           reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    STRING          reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    LPAREN          reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    IF              reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    NUMBER          reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    $end            reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    END             reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    AT              reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    ELSE            reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    RPAREN          reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 24 (comparison_exp -> arithmetic_exp IS_SMALLER arithmetic_exp .) ]


state 69

    (25) comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    OR              reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    SEMICOLON       reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    NAME            reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    FOR             reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    WHILE           reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    ECHO            reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    TRUE            reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    FALSE           reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    STRING          reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    LPAREN          reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    IF              reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    NUMBER          reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    $end            reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    END             reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    AT              reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    ELSE            reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    RPAREN          reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 25 (comparison_exp -> arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp .) ]


state 70

    (26) comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    OR              reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    SEMICOLON       reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    NAME            reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    FOR             reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    WHILE           reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    ECHO            reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    TRUE            reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    FALSE           reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    STRING          reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    LPAREN          reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    IF              reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    NUMBER          reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    $end            reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    END             reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    AT              reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    ELSE            reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    RPAREN          reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 26 (comparison_exp -> arithmetic_exp IS_EQUALS arithmetic_exp .) ]


state 71

    (27) comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    OR              reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    SEMICOLON       reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    NAME            reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    FOR             reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    WHILE           reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    ECHO            reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    TRUE            reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    FALSE           reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    STRING          reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    LPAREN          reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    IF              reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    NUMBER          reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    $end            reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    END             reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    AT              reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    ELSE            reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    RPAREN          reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .)
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35

  ! MINUS           [ reduce using rule 27 (comparison_exp -> arithmetic_exp IS_DIFFERENT arithmetic_exp .) ]


state 72

    (43) assignment -> NAME EQUALS expression .

    SEMICOLON       reduce using rule 43 (assignment -> NAME EQUALS expression .)
    NAME            reduce using rule 43 (assignment -> NAME EQUALS expression .)
    FOR             reduce using rule 43 (assignment -> NAME EQUALS expression .)
    WHILE           reduce using rule 43 (assignment -> NAME EQUALS expression .)
    ECHO            reduce using rule 43 (assignment -> NAME EQUALS expression .)
    TRUE            reduce using rule 43 (assignment -> NAME EQUALS expression .)
    FALSE           reduce using rule 43 (assignment -> NAME EQUALS expression .)
    STRING          reduce using rule 43 (assignment -> NAME EQUALS expression .)
    LPAREN          reduce using rule 43 (assignment -> NAME EQUALS expression .)
    MINUS           reduce using rule 43 (assignment -> NAME EQUALS expression .)
    IF              reduce using rule 43 (assignment -> NAME EQUALS expression .)
    NUMBER          reduce using rule 43 (assignment -> NAME EQUALS expression .)
    $end            reduce using rule 43 (assignment -> NAME EQUALS expression .)
    END             reduce using rule 43 (assignment -> NAME EQUALS expression .)
    AT              reduce using rule 43 (assignment -> NAME EQUALS expression .)
    ELSE            reduce using rule 43 (assignment -> NAME EQUALS expression .)


state 73

    (46) iterative_exp -> FOR assignment AT . boolean_exp AT bloc AT bloc END
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 46
    NAME            shift and go to state 47
    MINUS           shift and go to state 22
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 84
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    arithmetic_exp                 shift and go to state 48
    num                            shift and go to state 23
    float                          shift and go to state 26

state 74

    (47) iterative_exp -> FOR assignment boolean_exp . bloc AT bloc END
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    AND             shift and go to state 29
    OR              shift and go to state 30
    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    assignment                     shift and go to state 6
    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 85
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 75

    (48) iterative_exp -> WHILE boolean_exp AT . bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 86
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 76

    (49) iterative_exp -> WHILE boolean_exp bloc . END

    END             shift and go to state 87


state 77

    (34) arithmetic_exp -> LPAREN arithmetic_exp . RPAREN
    (22) comparison_exp -> arithmetic_exp . IS_BIGGER arithmetic_exp
    (23) comparison_exp -> arithmetic_exp . IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> arithmetic_exp . IS_SMALLER arithmetic_exp
    (25) comparison_exp -> arithmetic_exp . IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> arithmetic_exp . IS_EQUALS arithmetic_exp
    (27) comparison_exp -> arithmetic_exp . IS_DIFFERENT arithmetic_exp
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    RPAREN          shift and go to state 79
    IS_BIGGER       shift and go to state 36
    IS_BIGGER_EQUALS shift and go to state 37
    IS_SMALLER      shift and go to state 38
    IS_SMALLER_EQUALS shift and go to state 39
    IS_EQUALS       shift and go to state 40
    IS_DIFFERENT    shift and go to state 41
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35


state 78

    (21) boolean_exp -> LPAREN boolean_exp RPAREN .

    AND             reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    OR              reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    SEMICOLON       reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    NAME            reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    FOR             reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    WHILE           reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    ECHO            reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    TRUE            reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    FALSE           reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    STRING          reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    LPAREN          reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    MINUS           reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    IF              reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    NUMBER          reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    $end            reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    END             reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    AT              reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    ELSE            reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)
    RPAREN          reduce using rule 21 (boolean_exp -> LPAREN boolean_exp RPAREN .)


state 79

    (34) arithmetic_exp -> LPAREN arithmetic_exp RPAREN .

    PLUS            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    MINUS           reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    TIMES           reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    DIVIDE          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    MODULO          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_BIGGER       reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_BIGGER_EQUALS reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_SMALLER      reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_SMALLER_EQUALS reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_EQUALS       reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IS_DIFFERENT    reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    SEMICOLON       reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    NAME            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    FOR             reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    WHILE           reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    ECHO            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    TRUE            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    FALSE           reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    STRING          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    LPAREN          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    IF              reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    NUMBER          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    $end            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    END             reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    AT              reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    ELSE            reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    RPAREN          reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    AND             reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)
    OR              reduce using rule 34 (arithmetic_exp -> LPAREN arithmetic_exp RPAREN .)


state 80

    (28) comparison_exp -> LPAREN comparison_exp RPAREN .

    AND             reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    OR              reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    SEMICOLON       reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    NAME            reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    FOR             reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    WHILE           reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    ECHO            reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    TRUE            reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    FALSE           reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    STRING          reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    LPAREN          reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    MINUS           reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    IF              reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    NUMBER          reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    $end            reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    END             reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    AT              reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    ELSE            reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)
    RPAREN          reduce using rule 28 (comparison_exp -> LPAREN comparison_exp RPAREN .)


state 81

    (34) arithmetic_exp -> LPAREN arithmetic_exp . RPAREN
    (29) arithmetic_exp -> arithmetic_exp . PLUS arithmetic_exp
    (30) arithmetic_exp -> arithmetic_exp . MINUS arithmetic_exp
    (31) arithmetic_exp -> arithmetic_exp . TIMES arithmetic_exp
    (32) arithmetic_exp -> arithmetic_exp . DIVIDE arithmetic_exp
    (33) arithmetic_exp -> arithmetic_exp . MODULO arithmetic_exp

    RPAREN          shift and go to state 79
    PLUS            shift and go to state 31
    MINUS           shift and go to state 32
    TIMES           shift and go to state 33
    DIVIDE          shift and go to state 34
    MODULO          shift and go to state 35


state 82

    (44) conditional_exp -> IF boolean_exp AT . bloc END
    (45) conditional_exp -> IF boolean_exp AT . bloc ELSE bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 88
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 83

    (41) float -> NUMBER DOT NUMBER .

    PLUS            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    MINUS           reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    TIMES           reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    DIVIDE          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    MODULO          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_BIGGER       reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_BIGGER_EQUALS reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_SMALLER      reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_SMALLER_EQUALS reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_EQUALS       reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IS_DIFFERENT    reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    SEMICOLON       reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    NAME            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    FOR             reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    WHILE           reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    ECHO            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    TRUE            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    FALSE           reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    STRING          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    LPAREN          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    IF              reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    NUMBER          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    $end            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    END             reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    AT              reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    ELSE            reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    RPAREN          reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    AND             reduce using rule 41 (float -> NUMBER DOT NUMBER .)
    OR              reduce using rule 41 (float -> NUMBER DOT NUMBER .)


state 84

    (46) iterative_exp -> FOR assignment AT boolean_exp . AT bloc AT bloc END
    (14) boolean_exp -> boolean_exp . AND boolean_exp
    (15) boolean_exp -> boolean_exp . OR boolean_exp

    AT              shift and go to state 89
    AND             shift and go to state 29
    OR              shift and go to state 30


state 85

    (47) iterative_exp -> FOR assignment boolean_exp bloc . AT bloc END

    AT              shift and go to state 90


state 86

    (48) iterative_exp -> WHILE boolean_exp AT bloc . END

    END             shift and go to state 91


state 87

    (49) iterative_exp -> WHILE boolean_exp bloc END .

    SEMICOLON       reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    NAME            reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    FOR             reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    WHILE           reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    ECHO            reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    TRUE            reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    FALSE           reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    STRING          reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    LPAREN          reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    MINUS           reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    IF              reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    NUMBER          reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    $end            reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    END             reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    AT              reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)
    ELSE            reduce using rule 49 (iterative_exp -> WHILE boolean_exp bloc END .)


state 88

    (44) conditional_exp -> IF boolean_exp AT bloc . END
    (45) conditional_exp -> IF boolean_exp AT bloc . ELSE bloc END

    END             shift and go to state 92
    ELSE            shift and go to state 93


state 89

    (46) iterative_exp -> FOR assignment AT boolean_exp AT . bloc AT bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    assignment                     shift and go to state 6
    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 94
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 90

    (47) iterative_exp -> FOR assignment boolean_exp bloc AT . bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    assignment                     shift and go to state 6
    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 95
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 91

    (48) iterative_exp -> WHILE boolean_exp AT bloc END .

    SEMICOLON       reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    NAME            reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    FOR             reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    WHILE           reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    ECHO            reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    TRUE            reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    FALSE           reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    STRING          reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    LPAREN          reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    MINUS           reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    IF              reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    NUMBER          reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    $end            reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    END             reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    AT              reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)
    ELSE            reduce using rule 48 (iterative_exp -> WHILE boolean_exp AT bloc END .)


state 92

    (44) conditional_exp -> IF boolean_exp AT bloc END .

    SEMICOLON       reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    NAME            reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    FOR             reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    WHILE           reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    ECHO            reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    TRUE            reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    FALSE           reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    STRING          reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    LPAREN          reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    MINUS           reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    IF              reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    NUMBER          reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    $end            reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    END             reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    AT              reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)
    ELSE            reduce using rule 44 (conditional_exp -> IF boolean_exp AT bloc END .)


state 93

    (45) conditional_exp -> IF boolean_exp AT bloc ELSE . bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 96
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    assignment                     shift and go to state 6
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 94

    (46) iterative_exp -> FOR assignment AT boolean_exp AT bloc . AT bloc END

    AT              shift and go to state 97


state 95

    (47) iterative_exp -> FOR assignment boolean_exp bloc AT bloc . END

    END             shift and go to state 98


state 96

    (45) conditional_exp -> IF boolean_exp AT bloc ELSE bloc . END

    END             shift and go to state 99


state 97

    (46) iterative_exp -> FOR assignment AT boolean_exp AT bloc AT . bloc END
    (2) bloc -> . statement bloc
    (3) bloc -> . statement
    (4) statement -> . instruction SEMICOLON
    (5) statement -> . instruction
    (6) instruction -> . expression
    (7) instruction -> . assignment
    (8) instruction -> . iterative_exp
    (9) instruction -> . echo_exp
    (11) expression -> . boolean_exp
    (12) expression -> . arithmetic_exp
    (13) expression -> . conditional_exp
    (43) assignment -> . NAME EQUALS expression
    (46) iterative_exp -> . FOR assignment AT boolean_exp AT bloc AT bloc END
    (47) iterative_exp -> . FOR assignment boolean_exp bloc AT bloc END
    (48) iterative_exp -> . WHILE boolean_exp AT bloc END
    (49) iterative_exp -> . WHILE boolean_exp bloc END
    (10) echo_exp -> . ECHO bloc
    (14) boolean_exp -> . boolean_exp AND boolean_exp
    (15) boolean_exp -> . boolean_exp OR boolean_exp
    (16) boolean_exp -> . TRUE
    (17) boolean_exp -> . FALSE
    (18) boolean_exp -> . variable
    (19) boolean_exp -> . STRING
    (20) boolean_exp -> . comparison_exp
    (21) boolean_exp -> . LPAREN boolean_exp RPAREN
    (29) arithmetic_exp -> . arithmetic_exp PLUS arithmetic_exp
    (30) arithmetic_exp -> . arithmetic_exp MINUS arithmetic_exp
    (31) arithmetic_exp -> . arithmetic_exp TIMES arithmetic_exp
    (32) arithmetic_exp -> . arithmetic_exp DIVIDE arithmetic_exp
    (33) arithmetic_exp -> . arithmetic_exp MODULO arithmetic_exp
    (34) arithmetic_exp -> . LPAREN arithmetic_exp RPAREN
    (35) arithmetic_exp -> . MINUS arithmetic_exp
    (36) arithmetic_exp -> . num
    (37) arithmetic_exp -> . variable
    (38) arithmetic_exp -> . STRING
    (44) conditional_exp -> . IF boolean_exp AT bloc END
    (45) conditional_exp -> . IF boolean_exp AT bloc ELSE bloc END
    (42) variable -> . NAME
    (22) comparison_exp -> . arithmetic_exp IS_BIGGER arithmetic_exp
    (23) comparison_exp -> . arithmetic_exp IS_BIGGER_EQUALS arithmetic_exp
    (24) comparison_exp -> . arithmetic_exp IS_SMALLER arithmetic_exp
    (25) comparison_exp -> . arithmetic_exp IS_SMALLER_EQUALS arithmetic_exp
    (26) comparison_exp -> . arithmetic_exp IS_EQUALS arithmetic_exp
    (27) comparison_exp -> . arithmetic_exp IS_DIFFERENT arithmetic_exp
    (28) comparison_exp -> . LPAREN comparison_exp RPAREN
    (39) num -> . NUMBER
    (40) num -> . float
    (41) float -> . NUMBER DOT NUMBER

    NAME            shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    ECHO            shift and go to state 15
    TRUE            shift and go to state 16
    FALSE           shift and go to state 17
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 22
    IF              shift and go to state 24
    NUMBER          shift and go to state 25

    assignment                     shift and go to state 6
    boolean_exp                    shift and go to state 9
    bloc                           shift and go to state 100
    statement                      shift and go to state 3
    instruction                    shift and go to state 4
    expression                     shift and go to state 5
    iterative_exp                  shift and go to state 7
    echo_exp                       shift and go to state 8
    arithmetic_exp                 shift and go to state 10
    conditional_exp                shift and go to state 11
    variable                       shift and go to state 18
    comparison_exp                 shift and go to state 20
    num                            shift and go to state 23
    float                          shift and go to state 26

state 98

    (47) iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .

    SEMICOLON       reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    NAME            reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    FOR             reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    WHILE           reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    ECHO            reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    TRUE            reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    FALSE           reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    STRING          reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    LPAREN          reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    MINUS           reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    IF              reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    NUMBER          reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    $end            reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    END             reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    AT              reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)
    ELSE            reduce using rule 47 (iterative_exp -> FOR assignment boolean_exp bloc AT bloc END .)


state 99

    (45) conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .

    SEMICOLON       reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    NAME            reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    FOR             reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    WHILE           reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    ECHO            reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    TRUE            reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    FALSE           reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    STRING          reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    LPAREN          reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    MINUS           reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    IF              reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    NUMBER          reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    $end            reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    END             reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    AT              reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)
    ELSE            reduce using rule 45 (conditional_exp -> IF boolean_exp AT bloc ELSE bloc END .)


state 100

    (46) iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc . END

    END             shift and go to state 101


state 101

    (46) iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .

    SEMICOLON       reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    NAME            reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    FOR             reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    WHILE           reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    ECHO            reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    TRUE            reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    FALSE           reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    STRING          reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    LPAREN          reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    MINUS           reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    IF              reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    NUMBER          reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    $end            reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    END             reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    AT              reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)
    ELSE            reduce using rule 46 (iterative_exp -> FOR assignment AT boolean_exp AT bloc AT bloc END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NAME in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for ECHO in state 3 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 3 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 3 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 4 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 10 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 52 resolved as shift
WARNING: shift/reduce conflict for AND in state 59 resolved as shift
WARNING: shift/reduce conflict for OR in state 59 resolved as shift
WARNING: shift/reduce conflict for AND in state 60 resolved as shift
WARNING: shift/reduce conflict for OR in state 60 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 65 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 65 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 66 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 67 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 68 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (boolean_exp -> variable)
WARNING: rejected rule (arithmetic_exp -> variable) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (boolean_exp -> STRING)
WARNING: rejected rule (arithmetic_exp -> STRING) in state 19
